import random
from math import log, sqrt

class Agent:
    def __init__(self, Num:int) -> None:
        self.Num = Num
        
        #Action Value
        self.Qt_ls = [0.0] * Num
        self.Qt = 0.0
        self.Qt_prev = 0.0
        
        #Action
        self.action = 0
        self.Nt_ls = [0] * Num #Count of Actoin
            
        #UCB
        self.Ut_ls = [0] * Num

        self.QsU_ls = [0] * Num

        #Exploration
        self.Exploration_ls = [0] * Num

        #Exploitation
        self.Exploitation_ls = [0] * Num

        #Reward_sum
        self.Reward_sum_ls = [0] * Num
    
    def Reset(self):
        #Action Value
        self.Qt_ls = [0.0] * self.Num
        self.Qt = 0.0
        self.Qt_prev = 0.0
        
        #Action
        self.action = 0
        self.Nt_ls = [0] * self.Num #Count of Actoin
            
        #UCB
        self.Ut_ls = [0] * self.Num

        self.QsU_ls = [0] * self.Num

        #Exploration
        self.Exploration_ls = [0] * self.Num

        #Exploitation
        self.Exploitation_ls = [0] * self.Num

        #Reward_sum
        self.Reward_sum_ls = [0] * self.Num

    def Calculate_Action_Values(self, reward:int, Nt:int, Qt_prev:float):
        Qt = Qt_prev + (reward - Qt_prev)/Nt

        return Qt
    
    def Update_Action_Values(self, reward:int, action:int):

        if self.Nt_ls[action] != 0:
            self.Reward_sum_ls[action] += reward
            self.Qt_ls[action] = self.Calculate_Action_Values(reward, self.Nt_ls[action], self.Qt_ls[action])
        
        return self.Qt_ls, self.Reward_sum_ls
    
    def epsilon_greedy(self, epsilon:float):
        # Exploration
        if epsilon >= random.uniform(0,1.0):
            self.action = random.randrange(self.Num)
            self.Exploration_ls[self.action] += 1
            
        #Exploitation
        else:
            self.action = self.Qt_ls.index(max(self.Qt_ls))
            self.Exploitation_ls[self.action] += 1

        self.Nt_ls[self.action] += 1
        return self.action

    def Calculate_upper_confidence(self, c:float, t:int):
        for i in range(self.Num):
            if self.Nt_ls[i] == 0:
                self.Nt_ls[i] = 1
            if t == 0:
                t = 1
            self.Ut_ls[i] = c * (sqrt(log(t) / self.Nt_ls[i]))
        return self.Ut_ls

    def upper_confidence_bounds(self, c:float, t:int):
        self.Calculate_upper_confidence(c, t)
        self.QsU_ls = [Qt + Ut for Qt, Ut in zip(self.Qt_ls, self.Ut_ls)]
        self.action  = self.QsU_ls.index(max(self.QsU_ls))
        self.Nt_ls[self.action] += 1

        return self.action, self.Ut_ls
       
